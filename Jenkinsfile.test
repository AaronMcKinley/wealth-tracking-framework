pipeline {
  agent any
  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '10', artifactNumToKeepStr: '0'))
  }

  environment {
    CYPRESS_BASE_URL = "https://www.wealth-tracking-framework.com"
    REPORT_NAME = "E2E Tests"
    CYPRESS_WORKDIR = "wtf-cypress"
    CYPRESS_IMAGE = "custom-cypress:13.11"
    JUNIT_DIR = "wtf-cypress/cypress/results/junit"
    FAIL_DIR = "wtf-cypress/cypress/results/failures"
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Build Cypress Docker Image') {
      steps {
        dir("${CYPRESS_WORKDIR}") {
          sh "docker build --no-cache -t ${CYPRESS_IMAGE} ."
        }
      }
    }

    stage('Run Cypress E2E Tests') {
      steps {
        ansiColor('xterm') {
          catchError(buildResult: 'UNSTABLE', stageResult: 'UNSTABLE') {
            sh '''
              mkdir -p "$WORKSPACE/$CYPRESS_WORKDIR/allure-results" \
                      "$WORKSPACE/$CYPRESS_WORKDIR/cypress/screenshots" \
                      "$WORKSPACE/$CYPRESS_WORKDIR/cypress/videos" \
                      "$WORKSPACE/$JUNIT_DIR"
              rm -rf "$WORKSPACE/$FAIL_DIR"
              mkdir -p "$WORKSPACE/$FAIL_DIR"

              bash -o pipefail -c 'docker run --rm \
                --shm-size=1g \
                -e XDG_RUNTIME_DIR=/tmp \
                -u $(id -u):$(id -g) \
                -e FORCE_COLOR=1 \
                -e CYPRESS_allure=true \
                -e CYPRESS_allureResultsPath=/allure-results \
                -e CYPRESS_baseUrl=$CYPRESS_BASE_URL \
                -v "$WORKSPACE/$CYPRESS_WORKDIR/allure-results:/allure-results" \
                -v "$WORKSPACE/$CYPRESS_WORKDIR/cypress/screenshots:/app/cypress/screenshots" \
                -v "$WORKSPACE/$CYPRESS_WORKDIR/cypress/videos:/app/cypress/videos" \
                -v "$WORKSPACE/$JUNIT_DIR:/app/$JUNIT_DIR" \
                -v "$WORKSPACE/$FAIL_DIR:/app/$FAIL_DIR" \
                $CYPRESS_IMAGE \
                cypress run --e2e --browser chrome --headless \
                  --reporter junit \
                  --reporter-options mochaFile=$JUNIT_DIR/results-[hash].xml,toConsole=false \
                  --spec cypress/e2e/infra/robots.cy.js,cypress/e2e/signup/signup.cy.js,cypress/e2e/login/login.cy.js,cypress/e2e/addinvestment/addinvestment.cy.js,cypress/e2e/savings/savings.cy.js,cypress/e2e/transactions/transactions.cy.js,cypress/e2e/sidebar/sidebar.cy.js,cypress/e2e/sample.cy.js,cypress/e2e/signup/delete-account.cy.js 2>&1 | tee "$WORKSPACE/$FAIL_DIR/cypress-run.log"'
            '''
          }
        }
      }
    }

    stage('Allure Report') {
      steps {
        dir("${CYPRESS_WORKDIR}") {
          allure([results: [[path: 'allure-results']], reportBuildPolicy: 'ALWAYS'])
        }
      }
    }

    stage('Create ticket on failure') {
      when { expression { currentBuild.currentResult in ['UNSTABLE','FAILURE'] } }
      steps {
        withCredentials([string(credentialsId: 'GH_TOKEN', variable: 'GH_TOKEN')]) {
          script {
            def owner  = 'AaronMcKinley'
            def repo   = 'wealth-tracking-framework'
            def sha    = sh(script: 'git rev-parse --short=8 HEAD', returnStdout: true).trim()
            def branch = env.BRANCH_NAME ?: 'detached'
            def build  = env.BUILD_URL

            def candidates = [
              "${env.WORKSPACE}/cypress/results/failures/cypress-run.log",
              "${env.WORKSPACE}/wtf-cypress/cypress/results/failures/cypress-run.log"
            ]
            def logPath = candidates.find { fileExists(it) }
            def logText = logPath ? readFile(logPath) : ''
            logText = logText.replaceAll(/\u001B\[[0-9;]*[A-Za-z]/, '')

            def failingSpecs = []
            def specRe = /(?m)^[\s\|]*[âœ–xX]\s+([^\s]+?\.(?:cy|spec)\.(?:js|ts))/
            def ms = (logText =~ specRe)
            while (ms.find()) { failingSpecs << ms.group(1) }
            failingSpecs = failingSpecs.unique()

            def errMatch = (logText =~ /(?m)^(?:AssertionError|CypressError|Error|TypeError|ReferenceError).*$/)
            def shortErr = errMatch.find() ? errMatch.group(0) : null

            def overall = (logText =~ /(?m)\b(\d+ of \d+ failed.*)\b/)
            def overallLine = overall.find() ? overall.group(1) : null

            ms = null; errMatch = null; overall = null

            def title = "E2E ${currentBuild.currentResult.toLowerCase()}: ${branch} #${env.BUILD_NUMBER} (${sha})"

            def bodyLines = []
            bodyLines << "Build: ${build}"
            bodyLines << "Branch: ${branch}"
            bodyLines << "Commit: ${sha}"
            if (overallLine) bodyLines << "\n${overallLine}"

            if (failingSpecs && failingSpecs.size() > 0) {
              bodyLines << "\nFailing spec file" + (failingSpecs.size()>1 ? "s:" : ":")
              failingSpecs.each { bodyLines << "- `${it}`" }
            } else {
              bodyLines << "\nFailing spec files: (not detected)"
            }

            if (shortErr) {
              bodyLines << "\nError (first line):\n"
              bodyLines << "    ${shortErr}\n"
            }

            bodyLines << "\nJenkins console: ${build}console"

            def lines = logText ? logText.readLines() : []
            def startIdx = Math.max(0, lines.size() - 300)
            def tail = lines ? lines[startIdx..<lines.size()].join('\n') : '(no log tail available)'
            def tailIndented = tail.replaceAll('(?m)^', '    ')
            bodyLines << """
    <details>
    <summary>Console tail</summary>

    ${tailIndented}
    </details>
    """

            def payload = groovy.json.JsonOutput.toJson([
              title: title,
              body : bodyLines.join('\n')
            ])

            httpRequest acceptType: 'APPLICATION_JSON',
                        contentType: 'APPLICATION_JSON',
                        httpMode: 'POST',
                        customHeaders: [
                          [name: 'Authorization', value: 'token ' + env.GH_TOKEN],
                          [name: 'Accept', value: 'application/vnd.github+json'],
                          [name: 'X-GitHub-Api-Version', value: '2022-11-28']
                        ],
                        url: "https://api.github.com/repos/${owner}/${repo}/issues",
                        requestBody: payload,
                        validResponseCodes: '201'
          }
        }
      }
    }

    stage('Docker Cleanup') {
      steps {
        sh '''
          docker builder prune -af --filter "until=24h" || true
          docker image prune -af --filter "until=24h" || true
          docker container prune -f --filter "until=24h" || true
          docker volume prune -f || true
          docker system df || true
        '''
      }
    }
  }

    post {
      always {
        script {
          catchError(buildResult: 'SUCCESS', stageResult: 'SUCCESS') {
            build job: 'wtf-linting', wait: false, propagate: false
          }
        }

        archiveArtifacts artifacts: """
          ${CYPRESS_WORKDIR}/cypress/videos/**,
          ${CYPRESS_WORKDIR}/cypress/screenshots/**,
          ${CYPRESS_WORKDIR}/allure-results/**,
          ${CYPRESS_WORKDIR}/allure-report/**,
          ${JUNIT_DIR}/** ${FAIL_DIR}/**
        """, excludes: '**/node_modules/**', allowEmptyArchive: true
        cleanWs(deleteDirs: true)
      }
    }
}
